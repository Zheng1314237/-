#include "pch.h"
//#include "chess.h"
#include "MoveGenerator.h"

#ifdef _DEBUG
#undef THIS_FILE
static BYTE THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CMoveGenerator::CMoveGenerator()//构造函数
{
}

CMoveGenerator::~CMoveGenerator()//析构函数
{
}

//在m_MoveList中插入一个走法,nPly表明插入到List第几层
int CMoveGenerator::AddMove(int nFromX,int nFromY,int nToX,int nToY,int nPly,int nChessID)
{
	m_MoveList[nPly][m_nMoveCount].From.x = nFromX;
	m_MoveList[nPly][m_nMoveCount].From.y = nFromY;
	m_MoveList[nPly][m_nMoveCount].To.x = nToX;
	m_MoveList[nPly][m_nMoveCount].To.y = nToY;
	m_MoveList[nPly][m_nMoveCount].nChessID = nChessID;
	m_nMoveCount++;

	return m_nMoveCount;
}

//nPly指明当前搜索的层数，每层将走法存在不同的位置，以免覆盖
//nSide指明产生哪一方的走法，TRUE为红方，FALSE是黑方
int CMoveGenerator::CreatePossibleMove(BYTE position[][9],int nPly,int nSide,int nUserChessColor)
{
	int nChessID;
	int i,j;

	m_nMoveCount = 0;//将m_MoveList中走法的数量清0
	m_nUserChessColor = nUserChessColor;//记录用户棋子颜色

	for(j=0;j<9;j++)
		for(i=0;i<10;i++)
		{
			if(position[i][j] != NOCHESS)//如果棋盘某个位置有棋子
			{
				nChessID = position[i][j];

				if(nUserChessColor == REDCHESS)//如果用户执红色
				{
					if(!nSide && IsRed(nChessID)) continue;//如要产生黑棋走法，跳过红棋	
					if(nSide && IsBlack(nChessID)) continue;//如要产生红棋走法，跳过黑棋
				}
				else
				{
					if(nSide && IsRed(nChessID)) continue;//如要产生黑棋走法，跳过红棋	
					if(!nSide && IsBlack(nChessID)) continue;//如要产生红棋走法，跳过黑棋
				}

				switch(nChessID)
				{
				case R_KING://红帅
				case B_KING://黑将
					Gen_KingMove(position,i,j,nPly);
					break;

				case R_BISHOP://红士
					Gen_RBishopMove(position,i,j,nPly);
					break;
				
				case B_BISHOP://黑士
					Gen_BBishopMove(position,i,j,nPly);
					break;
				
				case R_ELEPHANT://红相
				case B_ELEPHANT://黑象
					Gen_ElephantMove(position,i,j,nPly);
					break;
				
				case R_HORSE://红马
				case B_HORSE://黑马
					Gen_HorseMove(position,i,j,nPly);
					break;
				
				case R_CAR://红车
				case B_CAR://黑车
					Gen_CarMove(position,i,j,nPly);
					break;

				case R_PAWN://红兵
					Gen_RPawnMove(position,i,j,nPly);
					break;
				
				case B_PAWN://黑卒
					Gen_BPawnMove(position,i,j,nPly);
					break;
				
				case B_CANON://黑炮
				case R_CANON://红炮
					Gen_CanonMove(position,i,j,nPly);
					break;
				
				default:
					break;
				}
			}
		}

	return m_nMoveCount;
}

//将/帅   将，帅一步的合理走法最多有4种，还有一种特殊情况是对老将，对老将多出9种走法，即敌方的九格
void CMoveGenerator::Gen_KingMove(BYTE position[10][9],int i,int j,int nPly)
{
	int x,y;
	
	for(y=0;y<3;y++)//生成黑将所有可能走法
		for(x=3;x<6;x++)
			if(IsValidMove(position,j,i,x,y,m_nUserChessColor))//如果符合规则就将这一走法添加进走法队列
				AddMove(j,i,x,y,nPly,position[i][j]);

	for(y=7;y<10;y++)//生成红帅所有可能走法
		for(x=3;x<6;x++)
			if(IsValidMove(position,j,i,x,y,m_nUserChessColor))//如果符合规则就将这一走法添加进走法队列
				AddMove(j,i,x,y,nPly,position[i][j]);
}

//红士    士一步的合理走法最多有4种
void CMoveGenerator::Gen_RBishopMove(BYTE position[10][9],int i,int j,int nPly)
{
	int x,y;
	
	for(y=7;y<10;y++)//生成红士所有可能走法
		for(x=3;x<6;x++)
			if(IsValidMove(position,j,i,x,y,m_nUserChessColor))//如果符合规则就将这一走法添加进走法队列
				AddMove(j,i,x,y,nPly,position[i][j]);
}

//黑士    士一步的合理走法最多有4种
void CMoveGenerator::Gen_BBishopMove(BYTE position[10][9],int i,int j,int nPly)
{
	int x,y;

	for(y=0;y<3;y++)//生成黑士所有可能走法
		for(x=3;x<6;x++)
			if(IsValidMove(position,j,i,x,y,m_nUserChessColor))//如果符合规则就将这一走法添加进走法队列
				AddMove(j,i,x,y,nPly,position[i][j]);
}

//象/相    象/相一步的合理走法最多有4种
void CMoveGenerator::Gen_ElephantMove(BYTE position[10][9],int i,int j,int nPly)
{
	int x,y;
	
	x=j+2;//测试向右下方走
	y=i+2;
	if(x<9 && y<10 && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);//如果没有走出棋盘且符合规则就将这一走法添加进走法队列
	
	x=j+2;//测试向右上方走
	y=i-2;
	if(x<9 && y>=0 && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);//如果没有走出棋盘且符合规则就将这一走法添加进走法队列
	
	x=j-2;//测试向左下方走
	y=i+2;
	if(x>=0 && y<10 && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);//如果没有走出棋盘且符合规则就将这一走法添加进走法队列

	x=j-2;//测试向左上方走
	y=i-2;
	if(x>=0 && y>=0 && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);//如果没有走出棋盘且符合规则就将这一走法添加进走法队列
}

//马    马一步的合理走法最多有8种
void CMoveGenerator::Gen_HorseMove(BYTE position[10][9], int i, int j, int nPly)
{
	int x, y;

	//插入右下方的有效走法
	x=j+2;//右2
	y=i+1;//下1
	if((x<9 && y<10) && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);

	//插入右下方的有效走法
	x = j + 1;//右1
	y = i + 2;//下2 
	if ((x<9 && y<10) && IsValidMove(position, j, i, x, y, m_nUserChessColor))
		AddMove(j, i, x, y, nPly, position[i][j]);

	//插入右上方的有效走法
	x=j+2;//右2
	y=i-1;//上1
	if((x<9 && y>=0) && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);

	//插入右上方的有效走法
	x = j + 1;//右1
	y = i - 2;//上2
	if ((x<9 && y >= 0) && IsValidMove(position, j, i, x, y, m_nUserChessColor))
		AddMove(j, i, x, y, nPly, position[i][j]);

	//插入左下方的有效走法
	x=j-2;//左2
	y=i+1;//下1
	if((x>=0 && y<10) && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);

	//插入左下方的有效走法
	x = j - 1;//左1
	y = i + 2;//下2
	if ((x >= 0 && y<10) && IsValidMove(position, j, i, x, y, m_nUserChessColor))
		AddMove(j, i, x, y, nPly, position[i][j]);

	//插入左上方的有效走法
	x=j-2;//左2
	y=i-1;//上1
	if((x>=0 && y>=0) && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);

	//插入左上方的有效走法
	x=j-1;//左1
	y=i-2;//上2
	if((x>=0 && y>=0) && IsValidMove(position,j,i,x,y,m_nUserChessColor))
		AddMove(j,i,x,y,nPly,position[i][j]);
}

//红兵   兵过河前一步的合理走法最多1种，过河后一步的合理走法最多有3种
void CMoveGenerator::Gen_RPawnMove(BYTE position[10][9], int i, int j, int nPly)
{
	int x,y;
	int nChessID;
	
	nChessID = position[i][j];//取棋子编号

	if(m_nUserChessColor == REDCHESS)//如果是红色
	{
		y=i-1;//向前走一步
		x=j;
		if(y>0 && !IsSameSide(nChessID,position[y][x]))//没有出棋局且前方没有自己的棋子
			AddMove(j,i,x,y,nPly,position[i][j]);//将该走法添加进走法队列
		
		if(i < 5)//已过河，可以左右走
		{
			y=i;//不前进
			
			x=j+1;//向右走一步
			if(x<9 && !IsSameSide(nChessID,position[y][x]))//没有出棋局且右方没有自己的棋子
				AddMove(j,i,x,y,nPly,position[i][j]);//将该走法添加进走法队列
			
			x=j-1;//向左走一步
			if(x>=0 && !IsSameSide(nChessID,position[y][x]))//没有出棋局且左方没有自己的棋子
				AddMove(j,i,x,y,nPly,position[i][j]);//将该走法添加进走法队列
		}
	}
	else
	{
		y=i+1;
		x=j;
		if(y>0 && !IsSameSide(nChessID,position[y][x]))
			AddMove(j,i,x,y,nPly,position[i][j]);
		
		if(i>4)
		{
			y=i;
			
			x=j+1;
			if(x<9 && !IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
			
			x=j-1;
			if(x>=0 && !IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
		}
	}
}

//黑卒   卒过河前一步的合理走法最多1种，过河后一步的合理走法最多有3种*************************************************
void CMoveGenerator::Gen_BPawnMove(BYTE position[10][9],int i,int j,int nPly)
{
	int x,y;
	int nChessID;
	
	nChessID=position[i][j];

	if(m_nUserChessColor == REDCHESS)
	{
		y=i+1;
		x=j;
		if(y<10 && !IsSameSide(nChessID,position[y][x]))
			AddMove(j,i,x,y,nPly,position[i][j]);
		
		if(i>4)
		{
			y=i;
			
			x=j+1;
			if(x<9 && !IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
			
			x=j-1;
			if(x>=0 && !IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
		}
	}
	else//如果是黑色
	{
		y=i-1;//向前
		x=j;
		if(y<10 && !IsSameSide(nChessID,position[y][x]))
			AddMove(j,i,x,y,nPly,position[i][j]);//前方无阻碍
		
		if(i<5)//是否已过河
		{
			y=i;
			
			x=j+1;//右边
			if(x<9 && !IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
			
			x=j-1;//左边
			if(x>=0 && !IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
		}
	}
}

//车    车一步的合理走法最多有17种
void CMoveGenerator::Gen_CarMove(BYTE position[10][9], int i, int j, int nPly)
{
	int x,y;
	int nChessID;
	
	nChessID = position[i][j];//取棋子标号

	x=j+1;//测试向右走
	y=i;
	while(x<9)//测试右边所有位置
	{
		if(NOCHESS == position[y][x])//如果该位置没有棋子，则该走法合法，添加进走法队列
			AddMove(j,i,x,y,nPly,position[i][j]);
		else
		{
			if(!IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
			//如果该位置是对方的棋，添加进走法队列，且该位置右边所有位置都不是合法落子点，跳出
			//如果该位置是自己的棋，该位置也不是合法落子点，直接跳出
			break;
		}
		x++;
	}

	x=j-1;//测试向左走
	y=i;
	while(x>=0)//测试左边所有位置
	{
		if(NOCHESS == position[y][x])//如果该位置没有棋子，则该走法合法，添加进走法队列
			AddMove(j,i,x,y,nPly,position[i][j]);
		else
		{
			if(!IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
			//如果该位置是对方的棋，添加进走法队列，且该位置左边所有位置都不是合法落子点，跳出
			//如果该位置是自己的棋，该位置也不是合法落子点，直接跳出
			break;
		}
		x--;
	}

	x=j;//测试向下走
	y=i+1;
	while(y<10)//测试下边所有位置
	{
		if(NOCHESS == position[y][x])//如果该位置没有棋子，则该走法合法，添加进走法队列
			AddMove(j,i,x,y,nPly,position[i][j]);
		else
		{
			if(!IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
			//如果该位置是对方的棋，添加进走法队列，且该位置下边所有位置都不是合法落子点，跳出
			//如果该位置是自己的棋，该位置也不是合法落子点，直接跳出
			break;
		}
		y++;
	}

	x=j;//测试向上走
	y=i-1;
	while(y>=0)//测试上边所有位置
	{
		if(NOCHESS == position[y][x])//如果该位置没有棋子，则该走法合法，添加进走法队列
			AddMove(j,i,x,y,nPly,position[i][j]);
		else
		{
			if(!IsSameSide(nChessID,position[y][x]))
				AddMove(j,i,x,y,nPly,position[i][j]);
			//如果该位置是对方的棋，添加进走法队列，且该位置上边所有位置都不是合法落子点，跳出
			//如果该位置是自己的棋，该位置也不是合法落子点，直接跳出
			break;
		}
		y--;
	}
}

//炮    
void CMoveGenerator::Gen_CanonMove(BYTE position[10][9], int i, int j, int nPly)
{
	int x,y;
	BOOL flag;
	int nChessID;
	
	nChessID = position[i][j];

	x=j+1;//测试向右走
	y=i;
	flag = FALSE;//标志位，现在假设没有隔棋子
	while(x<9)
	{
		if(NOCHESS == position[y][x])
		{
			if(!flag)//如没有隔棋子，则该点是合法落子点
				AddMove(j,i,x,y,nPly,position[i][j]);
		}
		else//测试向右走，遇到了棋子
		{
			if(!flag)//没有隔棋子，此棋子是第一个障碍，设置标志
				flag = TRUE;
			else//隔有棋子
			{
				if(!IsSameSide(nChessID,position[y][x]))
					AddMove(j,i,x,y,nPly,position[i][j]);
				//如果隔的棋子后面是对方棋子，则该位置为合法落子点，添加进走法队列直接跳出
				break;
			}
		}
		x++;//继续下一个位置
	}

	x=j-1;//测试向左走
	y=i;
	flag = FALSE;//标志位，现在假设没有隔棋子
	while(x>=0)
	{
		if(NOCHESS == position[y][x])
		{
			if(!flag)//如没有隔棋子，则该点是合法落子点
				AddMove(j,i,x,y,nPly,position[i][j]);
		}
		else
		{
			if(!flag)//没有隔棋子，此棋子是第一个障碍，设置标志
				flag=TRUE;
			else//隔有棋子
			{
				if(!IsSameSide(nChessID,position[y][x]))
					AddMove(j,i,x,y,nPly,position[i][j]);
				//如果隔的棋子后面是对方棋子，则该位置为合法落子点，添加进走法队列直接跳出
				break;
			}
		}
		x--;//继续下一个位置
	}

	x=j;//测试向下走
	y=i+1;
	flag = FALSE;//标志位，现在假设没有隔棋子
	while(y<10)
	{
		if(NOCHESS == position[y][x])
		{
			if(!flag)//如没有隔棋子，则该点是合法落子点
				AddMove(j,i,x,y,nPly,position[i][j]);
		}
		else
		{
			if(!flag)//没有隔棋子，此棋子是第一个障碍，设置标志
				flag=TRUE;
			else//隔有棋子
			{
				if(!IsSameSide(nChessID,position[y][x]))
					AddMove(j,i,x,y,nPly,position[i][j]);
				//如果隔的棋子后面是对方棋子，则该位置为合法落子点，添加进走法队列直接跳出
				break;
			}
		}
		y++;//继续下一个位置
	}

	x=j;//测试向上走
	y=i-1;
	flag = FALSE;//标志位，现在假设没有隔棋子
	while(y>=0)
	{
		if(NOCHESS==position[y][x])
		{
			if(!flag)//如没有隔棋子，则该点是合法落子点
				AddMove(j,i,x,y,nPly,position[i][j]);
		}
		else
		{
			if(!flag)//没有隔棋子，此棋子是第一个障碍，设置标志
				flag=TRUE;
			else//隔有棋子
			{
				if(!IsSameSide(nChessID,position[y][x]))
					AddMove(j,i,x,y,nPly,position[i][j]);
				//如果隔的棋子后面是对方棋子，则该位置为合法落子点，添加进走法队列直接跳出
				break;
			}
		}
		y--;//继续下一个位置
	}
}

//判断走法是否符合规则，合法返回true，非法返回false
BOOL CMoveGenerator::IsValidMove(BYTE position[10][9], int nFromX, int nFromY, int nToX, int nToY,int nUserChessColor)
{
	int i,j;
	int nMoveChessID,nTargetID;

	if(nFromX==nToX && nFromY==nToY) return false;//目的与源相同，非法

	nMoveChessID = position[nFromY][nFromX];//取源位置棋子标号
	nTargetID = position[nToY][nToX];//取目的位置棋子标号

	if(IsSameSide(nMoveChessID,nTargetID)) return false;//吃自己的棋，非法

	switch(nMoveChessID)
	{
	case B_KING://黑将
		if(nUserChessColor == REDCHESS)//玩家执红色
		{
			if(nTargetID == R_KING)//判断是否将帅见面
			{
				if(nFromX != nToX)//横坐标不相等
					return false;//将帅不在同一列
				
				for(i=nFromY+1;i<nToY;i++)
					if(position[i][nFromX] != NOCHESS)
						return false;//中间隔有棋子
			}
			else
			{
				if(nToY>2 || nToX>5 || nToX<3) return false;//目标点在九宫之外
				if(abs(nFromY-nToY)+abs(nFromX-nToX)>1) return false;//将帅只走一步直线
			}
		}
		else//玩家执黑色
		{
			if(nTargetID == R_KING)//判断是否将帅见面
			{
				if(nFromX != nToX)//横坐标不相等
					return false;//将帅不在同一列，不能对老将
				
				for(i=nFromY-1;i>nToY;i--)
					if(position[i][nFromX] != NOCHESS)
						return false;//中间隔有棋子，不能对老将
			}
			else
			{
				if(nToY<7 || nToX>5 || nToX<3) return false;//目标点在九宫之外	
				if(abs(nFromY-nToY)+abs(nFromX-nToX)>1) return false;//将帅只走一步直线
			}
		}
		break;
	//********************************************************************************************************
	case R_KING://红帅
		if(nUserChessColor == REDCHESS)//玩家执红色
		{
			if(nTargetID == B_KING)//判断是否将帅见面
			{
				if(nFromX != nToX)//横坐标不相等
					return false;//将帅不在同一列，不能对老将
				
				for(i=nFromY-1;i>nToY;i--)
					if(position[i][nFromX] != NOCHESS)
						return false;//中间隔有棋子，不能对老将
			}
			else
			{
				if(nToY<7 || nToX>5 || nToX<3) return false;//目标点在九宫之外	
				if(abs(nFromY-nToY)+abs(nFromX-nToX)>1) return false;//将帅只走一步直线
			}
		}
		else//玩家执黑色
		{
			if(nTargetID == B_KING)//判断是否将帅见面
			{
				if(nFromX != nToX)//横坐标不相等
					return false;//将帅不在同一列，不能对老将
				for(i=nFromY+1;i<nToY;i++)
					if(position[i][nFromX] != NOCHESS)
						return false;//中间隔有棋子，不能对老将
			}
			else
			{
				if(nToY>2 || nToX>5 || nToX<3) return false;//目标点在九宫之外
				if(abs(nFromY-nToY)+abs(nFromX-nToX)>1) return false;//将帅只走一步直线
			}
		}
		break;
	//*******************************************************************************************************
	case R_BISHOP://红士
		if(nUserChessColor == REDCHESS)
		{
			if(nToY<7 || nToX>5 || nToX<3) return false;//士出九宫
		}
		else
		{
			if(nToY>2 || nToX>5 || nToX<3) return false;//士出九宫
		}
		if(abs(nFromX-nToX)!=1 || abs(nFromY-nToY)!=1) return false;//士走斜线
		break;
	//******************************************************************************************************
	case B_BISHOP://黑士
		if(nUserChessColor == REDCHESS)
		{
			if(nToY>2 || nToX>5 || nToX<3) return false;//士出九宫
		}
		else
		{
			if(nToY<7 || nToX>5 || nToX<3) return false;//士出九宫
		}
		if(abs(nFromX-nToX)!=1 || abs(nFromY-nToY)!=1) return false;//士走斜线
		break;
	//*************************************************************************************************
	case R_ELEPHANT://红相
		if(nUserChessColor == REDCHESS)
		{
			if(nToY<5) return false;//相不能过河
		}
		else
		{
			if(nToY>4) return false;//相不能过河
		}
		if(abs(nFromX-nToX)!=2 || abs(nFromY-nToY)!=2) return false;//相走田字
		if(position[(nFromY +nToY)/2][(nFromX +nToX)/2] != NOCHESS) return FALSE;//相眼被塞
		break;
	//*************************************************************************************************
	case B_ELEPHANT://黑象
		if(nUserChessColor == REDCHESS)
		{
			if(nToY>4) return false;//象不能过河
		}
		else
		{
			if(nToY<5) return false;//象不能过河
		}
		if(abs(nFromX-nToX)!=2 || abs(nFromY-nToY)!=2) return false;//象走田字
		if(position[(nFromY +nToY)/2][(nFromX +nToX)/2] != NOCHESS) return FALSE;//象眼被塞
		break;
	//**************************************************************************************************
	case B_PAWN://黑卒
		if(nUserChessColor == REDCHESS)
		{
			if(nToY<nFromY) return false;//卒不能回头
			if(nFromY<5 && nFromY==nToY) return FALSE;//卒过河前只能直走
		}
		else
		{
			if(nToY>nFromY) return false;//卒不能回头
			if(nFromY>4 && nFromY==nToY) return FALSE;//卒过河前只能直走
		}
		if(nToY-nFromY+abs(nToX-nFromX)>1) return FALSE;//卒只走一步直线
		break;
	//**************************************************************************************************
	case R_PAWN://红兵
		if(nUserChessColor == REDCHESS)
		{
			if(nToY>nFromY) return false;//兵不能回头
			if(nFromY>4 && nFromY==nToY) return FALSE;//兵过河前只能直走
		}
		else
		{
			if(nToY<nFromY) return false;//兵不能回头
			if(nFromY<5 && nFromY==nToY) return FALSE;//兵过河前只能直走
		}
		if(nFromY-nToY+abs(nToX-nFromX)>1) return FALSE;//兵只走一步直线
		break;
	//****************************************************************************************************
	case B_CAR://黑车
	case R_CAR://红车
		if(nFromY!=nToY && nFromX!=nToX) return FALSE;//车走直线
		if(nFromY == nToY)
		{
			if(nFromX < nToX)
			{
				for(i=nFromX+1;i<nToX;i++)
					if(position[nFromY][i] != NOCHESS) return FALSE;
			}
			else
			{
				for(i=nToX+1;i<nFromX;i++)
					if(position[nFromY][i] != NOCHESS) return FALSE;
			}
		}
		else
		{
			if(nFromY < nToY)
			{
				for(j=nFromY+1;j<nToY;j++)
					if(position[j][nFromX] != NOCHESS) return FALSE;
			}
			else
			{
				for(j=nToY+1;j<nFromY;j++)
					if(position[j][nFromX] != NOCHESS) return FALSE;
			}
		}
		break;
	//*****************************************************************************************************
	case B_HORSE://黑马
	case R_HORSE://红马
		if(!((abs(nToX-nFromX)==1 && abs(nToY -nFromY)==2) || (abs(nToX-nFromX)==2&&abs(nToY -nFromY)==1)))
			return FALSE;//马走日字
		if(nToX-nFromX == 2)
		{
			i=nFromX+1;
			j=nFromY;
		}
		else
			if(nFromX-nToX == 2)
			{
				i=nFromX-1;
				j=nFromY;
			}
			else
				if(nToY-nFromY == 2)
				{
					i=nFromX;
					j=nFromY+1;
				}
				else
					if(nFromY-nToY == 2)
					{
						i=nFromX;
						j=nFromY-1;
					}

		if(position[j][i] != NOCHESS) return FALSE;//绊马腿
		break;
	//******************************************************************************************************
	case B_CANON://黑炮
	case R_CANON://红炮
		if(nFromY!=nToY && nFromX!=nToX) return FALSE;//炮走直线

		if(position[nToY][nToX] == NOCHESS)//炮不吃子时经过的路线中不能有棋子
		{
			if(nFromY == nToY)
			{
				if(nFromX < nToX)
				{
					for(i=nFromX+1;i<nToX;i++)
						if(position[nFromY][i] != NOCHESS) return FALSE;
				}
				else
				{
					for(i=nToX+1;i<nFromX;i++)
						if(position[nFromY][i] != NOCHESS) return FALSE;
				}
			}
			else
			{
				if(nFromY < nToY)
				{
					for(j=nFromY+1;j<nToY;j++)
						if(position[j][nFromX] != NOCHESS) return FALSE;
				}
				else
				{
					for(j=nToY+1;j<nFromY;j++)
						if(position[j][nFromX] != NOCHESS) return FALSE;
				}
			}
		}		
		else//炮吃子时
		{
			int j=0;
			if(nFromY == nToY)
			{
				if(nFromX < nToX)
				{
					for(i=nFromX+1;i<nToX;i++)
						if(position[nFromY][i] != NOCHESS) j++;
						if(j != 1) return FALSE;
				}
				else
				{
					for(i=nToX+1;i<nFromX;i++)
						if(position[nFromY][i] != NOCHESS) j++;
						if(j != 1) return FALSE;
				}
			}
			else
			{
				if(nFromY < nToY)
				{
					for(i=nFromY+1;i<nToY;i++)
						if(position[i][nFromX] != NOCHESS) j++;
					if(j != 1) return FALSE;
				}
				else
				{
					for(i=nToY+1;i<nFromY;i++)
						if(position[i][nFromX] != NOCHESS) j++;
					if(j != 1) return FALSE;
				}
			}
		}
		break;
	//********************************************************************************************************
	default:
		return false;
	}
		
	return true;
}
